- 기본 예제 3 - 가게의 매출을 구할 수 있는 Shop 클래스 작성
```python
class Shop:
    total = 0
    menu_list = [{'떡볶이' : 3000}, {'순대' : 4000}, {'튀김' : 500}, {'김밥' : 2000}]
    menu_dict = {
        '떡볶이' : 3000,
        '순대' : 4000,
        '튀김' : 500,
        '김밥' : 2000
    }

    @classmethod
    def get_total(cls):
        return cls.total

    @classmethod
    def sales1(cls, menu_name, num):
        """ list의 내부의 dictionary를 반복하여 menu_name과 일치하는 key를 찾아 value를 return """
        # for menu in cls.menu_list:
        #     # print(menu)      # 결과값 : {'떡볶이' : 3000}, {'순대' : 4000}, {'튀김' : 500}, {'김밥' : 2000} -> 이걸 하나씩 파고 들어가기 위해 for문을 하나 더 씀
        #     for item in menu:
        #         if item == menu_name :
        #             cls.total += menu[item] * num
        #             print(f'{menu_name}을(를) {num}개 판매')

        for menu_dict in cls.menu_list:
            if menu_name in menu_dict:   # 딕셔너리 내에 pair 하나밖에 없는 상태인데, 있으면 이하의 코드라인이 실행되고 아니면 넘어갈겁니다. 그러면 다음 반복으로 가겠네요.
                # in -> element를 기준해야 하기 때문에 dictionary의 element 중 'key'를 기준
                cls.total += menu_dict[menu_name] * num
                print(f'{menu_name}을(를) {num}개 판매')

    @classmethod
    def sales2(cls, menu_name, num):
        if menu_name in cls.menu_dict:
            cls.total += cls.menu_dict[menu_name] * num
            print(f'{menu_name}을(를) {num}개 판매')

Shop.sales1('떡볶이', 1)
Shop.sales1('김밥', 2)
print(f'매출 : {Shop.get_total()}원')

Shop.sales2('떡볶이', 1)
print(f'매출 : {Shop.get_total()}원')
```
- sales1 에서 중복 for문을 써서 풀이했지만 `if menu_name in menu_dict:`로 for문을 하나 더 안쓰고 답을 낼 수 있음.
  - 딕셔너리 내에 pair 하나밖에 없는 상태인데, 있으면 이하의 코드라인이 실행되고 아니면 넘어가고 다음 반복으로 감. 
  - in -> element를 기준해야 하기 때문에 dictionary의 element 중 'key'를 기준으로 함

# python prettytable
- 외부 패키지의 설치 # 1 settings를 통한 방법 -> settings에서 프로젝트명 클릭 -> prettytable 검색 후 설치
- 파일에서 사용 시 `from prettytable import PrettyTable`
- `field_names` : 테이블의 필드 이름(열 헤더)를 설정하거나 가져오는데 사용하는 메서드
  - 필드 이름 설정:`field_names`에 문자열 리스트를 할당하여 테이블의 헤더를 정의
  - 필드 이름 가져오기: `field_names`를 액세스하면 현재 헤더를 가져올 수 있음
- `add_row` : 테이블의 단일 행을 추가하는데 사용되는 메서드
  - 행 추가: `field_names`에 정의된 각 필드에 해당하는 값 리스트를 제공해야함. 리스트의 값 개수는 필드 이름의 개수와 일치해야 함
- `add_rows` : 테이블의 다중 행을 추가하는데 사용되는 메서드
사용 예시
```python
from prettytable import PrettyTable

table = PrettyTable()       # 객체 생성
table.field_names = ["필드1", "필드2", "필드3"]

table.add_row(("값1", "값2", "값3"))
```
결과
+-------+-------+-------+
| 필드1 | 필드2 | 필드3 |
+-------+-------+-------+
|  값1  |  값2  |  값3  |
+-------+-------+-------+

# python 예외 처리
1. 예외 처리의 필요성
    1) 예외(exception) : 개발자가 직접 처리할 수 있는 문제
    2) 오류(error) : 개발자가 처리할 수 없는 문제

    3) 예외 처리의 목적 :
        어떤 문제가 발생했을 때 그 문제를 해결해주는 것이 아니라, 발생된 문제로 인해 프로그램이 비정상적으로 종료되는 것을 막고, 사용자에게 발생한 문제에 대해 정보를 전달하기 위함.

2. 예외 처리
    1) 고전적 예외 처리
        - 어떤 값이든 0으로 나눌 수 없기 때문에 if a == 0 을 통해 0으로 나누는 것을 아예 시도할 수 없도록 예외처리를 함.

        - 여기서 생각할 수 있는 문제는 :
            1) 어떤 문제가 발생할 지 예상할 수 있어야 미리 대비할 수 있다.
            2) 어떤 문제가 발생할 지 예상할 수 있더라도 대비할 수 없는 경우가 있다.

3. 예외 처리의 종류
   1) BaseException : 최상의 예외 클래스
   2) Exception :  대부분 예외 클래스의 슈퍼 클래스
   3) ArithmeticError : 산술 연산에 문제가 있을 때
   4) AttributeError : 잘못된 속성을 참조할 때
   5) EOFError : 파일에서 더 이상 읽어 들일 데이터가 없을 때
   6) ModuleNotFoundError : import할 모듈이 없을 때
   7) FileNotFoundError : 존재하지 않는 파일일 때
   8) IndexError : 잘못된 인덱스를 사 : 
   9) NameError : 잘못된 이름(변수)을 사용할 때
   10) SyntaxError : 문법이 틀렸을 때
   11) TypeError : 계산하려는 데이터의 유형이 잘못되었을 때
   12) ValueError : 계산하려는 데이터의 값이 잘못 되었을 때

4. 예외 처리 방식
   1) 모든 예외를 처리하는 방식 -> try / except / finally
   2) 특정 예외만 처리하는 방식
      try / except 문을 사용하면 기본적으로 예외의 종류에 상관없이 모든 예외가 처리됨. 하지만 서로 다른 메시지를 출력해줄 수 있다면, 개발자에게 예외를 처리할 수 있을만한 추가적인 정보를 제공할 수 있음.
      특정 예외에 따른 서로 다른 안내문을 제시한다고 하면, except문 뒤에 처리하고자 하는 예외를 모두 명시하면 됨
      except의 마지막에 Exception을 명시하면 예상하지 못한 예외들도 웬만하면 처리 됨
      - Exception이 가장 상위에 있게 되면 모든 예외가 전부 Exception으로 잡히기 때문에 순서 역시 중요
      
5. 예외 메시지 처리하기
    기본적으로 이미 예외 메시지를 가지고 있는 경우도 있음

6. else / finally
    else : 예외가 발생하지 않으면 처리되는 구문
    finally : 예외 발생 여부와 관계 없이 맨 마지막에 항상 처리되는 구문

7. 강제로 예외를 발생시키기
    - raise문
    - 형식 : raise 예외클래스() 또는 raise 예외클래스(예외메시지)
    - raise의 경우 강제로 예외를 발생시킨다는 점에서 주로 사용되는 예외 클래스는 Exception

8. 사용자 정의 예외 클래스
    - class 클래스명(Exception) : 본문    - Exception 클래스를 상속 받았다는 의미

최종 형식
try :
    코드 작성 영역
    raise Exception('강제로 발생시킨 예외입니다.')
except 예외 클래스1 :
    예외 메시지1
except 예외 클래스2 :
    예외 메시지2
except Exception as e :
    예외 메시지 n
else :
    예외가 발생하지 않았을 때 실행되는 코드 영역
finally : 
    항시 실행되는 코드 영역

- 예시
```python
try :
    a = int(input('나누는 수를 정수로 입력하세요 >>> '))
    b = int(input('나누어지는 수를 정수로 입력하세요 >>> '))
    result = b / a      
except ZeroDivisionError as e:
    print(e)
except TypeError as e:
    print(e)
except ValueError as e:
    print(e)
else :
    print(f'b / a = {result}')
finally:
    print('프로그램이 종료되었습니다.')
```
이상의 상황에서 ZeroDivisionError가 예외 처리했음에도 불구하고
a=0 b=아무정수 를 넣었을때 ZeroDivisionError가 예외 처리되지 않고 오류 발생을 함

try / except문이 없는 상태에서 다양하게 검증해보고 어떤 예외가 발생하는지 체크해야함
그리고 그 발생한 예외들에 대한 except 문을 작성해야하고, 정상적으로 처리가 되었을 때 else문을 작성

하지만 이상의 사례와 같이 a = 0을 입력하는 것 자체가 예외를 발생시키지 않고,
1. a = 0 이면서,
2. b / a 연산을 시도할 때 ZerodivisionError가 발생하기 때문에,

else 문에 b / a가 포함되어서는 안됨
그래서 try문 내에 result = b / a 를 작성함으로써 그 부분이 예외 없이 통과되었을 때만 연산 결과가 출력될 수 있도록 else에 `print(f'b / a = {reault}')`를 작성함 

- 예제 1
```python
try :
    number = int(input('숫자를 입력하세요 >>> '))
    result =  100 / number
    print(f'100 / {number} = {result}')
except ZeroDivisionError as e:
    print('0으로 나눌 수 없습니다.')
except ValueError as e:
    print('정수만 입력할 수 있습니다.')
else :
    print('정상적으로 처리되었습니다.')
finally:
    print('프로그램 종료')
```

- 에제 2
```python
my_list = [10, 20, 30, 40, 50]

class NegativeNumIndexError(Exception) :
    pass

try :
    n = int(input('리스트의 인덱스를 입력하시오. >>> '))
    if n < 0 :
        raise NegativeNumIndexError()
    print(my_list[n])
except NegativeNumIndexError as e:
    print('마이너스 인덱스는 적용시키지 않습니다.')
except IndexError as e :
    print('인덱스가 리스트 범위를 넘어갔습니다.')
except ValueError as e :
    print('정수만 입력해야합니다.')
except Exception as e :
    print('예상할 수 없는 예외가 발생했습니다.')
else :
    print('정상적으로 처리되었습니다.')
finally:
    print('프로그램 종료')
```

- 예제 3
  - getattr(객체명, 속성명_str) - 특정 객체의 두번째 argument와 일치하는 속성명의 값을 return
  - vars(객체명) - 특정 객체의 속성명 - 속성값 쌍을 dictionary 형태의 key-value 쌍으로 변환하여 리턴
```python
class Person:
    school = '코리아아이티대학교'

    def __init__(self, name, age):
        self.name = name
        self.age = age

# 객체 생성
person1 = Person(name='김일', age=21)

try :
    attr_name = input('출력할 속성명을 입력하시오 >>> ')
    attr_value = getattr(person1,attr_name)
    print(getattr(person1, attr_name))
except AttributeError as e :
    print('존재하지 않는 속성입니다.')
except Exception as e :
    print('예측할 수 없는 예외가 발생했습니다.')
else :
    print('정상적으로 처리되었습니다.')
finally:
    print('프로그램 종료')
```

# 상속(Inheritance)
형식 :
class 슈퍼 클래스 :
    본문
class 서브 클래스(슈퍼클래스) :
    본문

```python
class Person:
    def __init__(self, name):
        self.name = name

    def eat(self, food):
        print(f'{self.name}이(가) {food}를 먹습니다.')

class Student(Person):
    def __init__(self, name, school):
        super().__init__(name)
        self.school = school

    def study(self):
        print(f'{self.name}은(는) {self.school}에서 공부를 합니다.')

# 객체 생성
potter = Student('해리포터', '호그와트')
potter.eat('감자')
potter.study()
```
이상의 코드에서 주목해야 할 점은 
1. Student 클래스에 정의되지 않은 메서드인 .eat()을 52번 라인에서 호출했다는 점
2. Student 클래스의 생성자에서 확인되는 `super().__init__(name)`입니다.
    - 해당 부분은 슈퍼 클래스의 생성자를 호출하는 방식입니다.
    - Java에서는 슈퍼 클래스의 생성자 호출 방식이 super()
    - Java에서 슈퍼 클래스의 메서드 호출 방식 super.메서드명()
```python
def eat(self, food):
    print(f'{self.school}에서', end=' ')
    super().eat(food)
```
만약에 이상과 같이 슈퍼 클래스의 메서드인 .eat()을 override하여 `재정의`하는 것도 가능합니다.
Java와 달리 python에서는 기본적으로 `super().`을 베이스로 한다는 것을 알 수 있습니다.
생성자나 소멸자가 __가 앞뒤로 붙기는 하지만 기본적으로 method라는 사실을 알고 계신다면 Java보다 오히려 더 일괄적인 방식으로 코드를 작성한다는 점도 확인할 수 있겠습니다.